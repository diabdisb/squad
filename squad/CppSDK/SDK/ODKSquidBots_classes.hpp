#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ODKSquidBots

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class ODKSquidBots.ODKSquidBotsProjectInterface
// 0x0000 (0x0028 - 0x0028)
class UODKSquidBotsProjectInterface : public UObject
{
public:
	bool CanUseFullAutoSounds() const;
	class USoundBase* GetSemiAutoSound(const class UObject* StaticInfo, const class UObject* EquipableItem) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSquidBotsProjectInterface">();
	}
	static class UODKSquidBotsProjectInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKSquidBotsProjectInterface>();
	}
};
static_assert(alignof(UODKSquidBotsProjectInterface) == 0x000008, "Wrong alignment on UODKSquidBotsProjectInterface");
static_assert(sizeof(UODKSquidBotsProjectInterface) == 0x000028, "Wrong size on UODKSquidBotsProjectInterface");

// Class ODKSquidBots.ODKAvatar
// 0x0010 (0x04D0 - 0x04C0)
class AODKAvatar final : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Seed;                                              // 0x04C0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetSquidBotsShowAimArrowsDebug();
	bool GetSquidBotsShowAimToleranceConesDebug();
	void OnRep_HealthChanged(const float PreviousHealth);
	void OnToggleShowAimArrowsDebug(bool bEnabled);
	void SetHealth(const float InHealth);

	float GetHealth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKAvatar">();
	}
	static class AODKAvatar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AODKAvatar>();
	}
};
static_assert(alignof(AODKAvatar) == 0x000010, "Wrong alignment on AODKAvatar");
static_assert(sizeof(AODKAvatar) == 0x0004D0, "Wrong size on AODKAvatar");
static_assert(offsetof(AODKAvatar, Seed) == 0x0004C0, "Member 'AODKAvatar::Seed' has a wrong offset!");
static_assert(offsetof(AODKAvatar, Health) == 0x0004C4, "Member 'AODKAvatar::Health' has a wrong offset!");

// Class ODKSquidBots.ODKFireEvent
// 0x0008 (0x0030 - 0x0028)
class UODKFireEvent final : public UObject
{
public:
	class UODKFireEvent*                          NetSerializationDefaultObject;                     // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKFireEvent">();
	}
	static class UODKFireEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKFireEvent>();
	}
};
static_assert(alignof(UODKFireEvent) == 0x000008, "Wrong alignment on UODKFireEvent");
static_assert(sizeof(UODKFireEvent) == 0x000030, "Wrong size on UODKFireEvent");
static_assert(offsetof(UODKFireEvent, NetSerializationDefaultObject) == 0x000028, "Member 'UODKFireEvent::NetSerializationDefaultObject' has a wrong offset!");

// Class ODKSquidBots.ODKGenericItem
// 0x0030 (0x0258 - 0x0228)
class AODKGenericItem final : public AActor
{
public:
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Seed;                                              // 0x0230(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     SpawnClass;                                        // 0x0238(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UODKInventoryItem*                      InventoryItem;                                     // 0x0240(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UODKFireEvent>              FireEventClass;                                    // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiringInput;                                      // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SpawnGenericItem(const class UObject* InWorldContextObject, const TSubclassOf<class AODKGenericItem>& InGenericItemClass, const TSubclassOf<class AActor>& InSpawnClass, const struct FTransform& InTransform, class AActor* InOwner, class APawn* InInstigator, class UODKInventoryItem* InInventoryItem, const int32 InSeed);

	bool CanFire();
	void ClientTick(const float DeltaSeconds);
	void CycleFire(const bool bIsAutomaticFire);
	void ForceSingleFire();
	void InstantFire(const class UODKFireEvent* FireEvent);
	void MulticastFire(const struct FODKNetSerializedObject& SerializedFireEvent, const bool bIsAutomaticFire);
	void MulticastStopAutomaticFiring();
	void OnStartedAutomaticFiring();
	void OnStoppedAutomaticFiring();
	void PrepareFire(class UODKFireEvent* SerializationObject);
	void ServerTick(const float DeltaSeconds);

	float GetTimeBetweenAutomaticShots() const;
	float GetTimeBetweenManualShots() const;
	bool GetUsingAutomaticFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKGenericItem">();
	}
	static class AODKGenericItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AODKGenericItem>();
	}
};
static_assert(alignof(AODKGenericItem) == 0x000008, "Wrong alignment on AODKGenericItem");
static_assert(sizeof(AODKGenericItem) == 0x000258, "Wrong size on AODKGenericItem");
static_assert(offsetof(AODKGenericItem, Seed) == 0x000230, "Member 'AODKGenericItem::Seed' has a wrong offset!");
static_assert(offsetof(AODKGenericItem, SpawnClass) == 0x000238, "Member 'AODKGenericItem::SpawnClass' has a wrong offset!");
static_assert(offsetof(AODKGenericItem, InventoryItem) == 0x000240, "Member 'AODKGenericItem::InventoryItem' has a wrong offset!");
static_assert(offsetof(AODKGenericItem, FireEventClass) == 0x000248, "Member 'AODKGenericItem::FireEventClass' has a wrong offset!");
static_assert(offsetof(AODKGenericItem, bFiringInput) == 0x000250, "Member 'AODKGenericItem::bFiringInput' has a wrong offset!");

// Class ODKSquidBots.ODKInventoryItem
// 0x0000 (0x0028 - 0x0028)
class UODKInventoryItem final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKInventoryItem">();
	}
	static class UODKInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKInventoryItem>();
	}
};
static_assert(alignof(UODKInventoryItem) == 0x000008, "Wrong alignment on UODKInventoryItem");
static_assert(sizeof(UODKInventoryItem) == 0x000028, "Wrong size on UODKInventoryItem");

// Class ODKSquidBots.ODKNetSerializedObjectHelpers
// 0x0000 (0x0028 - 0x0028)
class UODKNetSerializedObjectHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void ReadObject(const struct FODKNetSerializedObject& NetSerializedObject, class UObject* OutObjectToWriteInto, const class UObject* WorldContextObject);
	static struct FODKNetSerializedObject WriteObject(class UObject* InObject, const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKNetSerializedObjectHelpers">();
	}
	static class UODKNetSerializedObjectHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKNetSerializedObjectHelpers>();
	}
};
static_assert(alignof(UODKNetSerializedObjectHelpers) == 0x000008, "Wrong alignment on UODKNetSerializedObjectHelpers");
static_assert(sizeof(UODKNetSerializedObjectHelpers) == 0x000028, "Wrong size on UODKNetSerializedObjectHelpers");

// Class ODKSquidBots.ODKSeededRandom
// 0x0000 (0x0028 - 0x0028)
class IODKSeededRandom final : public IInterface
{
public:
	void RandomizeSeed();

	int32 GetRandomSeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSeededRandom">();
	}
	static class IODKSeededRandom* GetDefaultObj()
	{
		return GetDefaultObjImpl<IODKSeededRandom>();
	}
};
static_assert(alignof(IODKSeededRandom) == 0x000008, "Wrong alignment on IODKSeededRandom");
static_assert(sizeof(IODKSeededRandom) == 0x000028, "Wrong size on IODKSeededRandom");

// Class ODKSquidBots.ODKSequencerHelpers
// 0x0000 (0x0028 - 0x0028)
class UODKSequencerHelpers final : public UBlueprintFunctionLibrary
{
public:
	static int64 GetFrameNum();
	static int32 GetRandomSeedAtFrame(const TScriptInterface<class IODKSeededRandom> SeededRandom);
	static float GetTime(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSequencerHelpers">();
	}
	static class UODKSequencerHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKSequencerHelpers>();
	}
};
static_assert(alignof(UODKSequencerHelpers) == 0x000008, "Wrong alignment on UODKSequencerHelpers");
static_assert(sizeof(UODKSequencerHelpers) == 0x000028, "Wrong size on UODKSequencerHelpers");

// Class ODKSquidBots.ODKSquidBotsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UODKSquidBotsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	static class UBlackboardComponent* GetBlackboard(class AActor* Actor);
	static class AGameModeBase* GetGameMode(const class UObject* WorldContextObject);
	static class AActor* GetInstigatorOrSelf(class AActor* Actor);
	static bool IsCompilingBlueprint();
	static bool IsEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSquidBotsBlueprintLibrary">();
	}
	static class UODKSquidBotsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKSquidBotsBlueprintLibrary>();
	}
};
static_assert(alignof(UODKSquidBotsBlueprintLibrary) == 0x000008, "Wrong alignment on UODKSquidBotsBlueprintLibrary");
static_assert(sizeof(UODKSquidBotsBlueprintLibrary) == 0x000028, "Wrong size on UODKSquidBotsBlueprintLibrary");

// Class ODKSquidBots.ODKSquidBotsBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UODKSquidBotsBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetRandomInt32();
	static bool IsEditorTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSquidBotsBPLibrary">();
	}
	static class UODKSquidBotsBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKSquidBotsBPLibrary>();
	}
};
static_assert(alignof(UODKSquidBotsBPLibrary) == 0x000008, "Wrong alignment on UODKSquidBotsBPLibrary");
static_assert(sizeof(UODKSquidBotsBPLibrary) == 0x000028, "Wrong size on UODKSquidBotsBPLibrary");

// Class ODKSquidBots.ODKSquidBotsSettings
// 0x0010 (0x0048 - 0x0038)
class UODKSquidBotsSettings final : public UDeveloperSettings
{
public:
	TSubclassOf<class UODKSquidBotsProjectInterface> SquidBotsProjectImplementationClass;               // 0x0038(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UODKSquidBotsProjectInterface*          SquidBotsProjectImplementation;                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static const class UODKSquidBotsProjectInterface* GetSquidBotsProjectImplementationBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSquidBotsSettings">();
	}
	static class UODKSquidBotsSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UODKSquidBotsSettings>();
	}
};
static_assert(alignof(UODKSquidBotsSettings) == 0x000008, "Wrong alignment on UODKSquidBotsSettings");
static_assert(sizeof(UODKSquidBotsSettings) == 0x000048, "Wrong size on UODKSquidBotsSettings");
static_assert(offsetof(UODKSquidBotsSettings, SquidBotsProjectImplementationClass) == 0x000038, "Member 'UODKSquidBotsSettings::SquidBotsProjectImplementationClass' has a wrong offset!");
static_assert(offsetof(UODKSquidBotsSettings, SquidBotsProjectImplementation) == 0x000040, "Member 'UODKSquidBotsSettings::SquidBotsProjectImplementation' has a wrong offset!");

// Class ODKSquidBots.ODKSuppressionNotificationInterface
// 0x0000 (0x0028 - 0x0028)
class IODKSuppressionNotificationInterface final : public IInterface
{
public:
	void Suppress(const struct FVector& ProjectileOrigin, const struct FVector& ProjectileDirection, TSubclassOf<class AActor>& ProjectileClass, const class AActor* Instigator);

	bool DoesComponentReceiveSuppression(const class UPrimitiveComponent* Component) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ODKSuppressionNotificationInterface">();
	}
	static class IODKSuppressionNotificationInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IODKSuppressionNotificationInterface>();
	}
};
static_assert(alignof(IODKSuppressionNotificationInterface) == 0x000008, "Wrong alignment on IODKSuppressionNotificationInterface");
static_assert(sizeof(IODKSuppressionNotificationInterface) == 0x000028, "Wrong size on IODKSuppressionNotificationInterface");

}

